[ ![PostgreSQL Elephant Logo](/media/img/about/press/elephant.png) ](/)

  * [Home](/ "Home")
  * [About](/about/ "About")
  * [Download](/download/ "Download")
  * [Documentation](/docs/ "Documentation")
  * [Community](/community/ "Community")
  * [Developers](/developer/ "Developers")
  * [Support](/support/ "Support")
  * [Donate](/about/donate/ "Donate")
  * [Your account](/account/ "Your account")

__

May 8, 2025: [ PostgreSQL 17.5, 16.9, 15.13, 14.18, and 13.21 Released! ](/about/news/postgresql-175-169-1513-1418-and-1321-released-3072/) | [ PostgreSQL 18 Beta 1 Released! ](/about/news/postgresql-18-beta-1-released-3070/)

[Documentation](/docs/ "Documentation") -> [PostgreSQL
16](/docs/16/index.html)

Supported Versions: [Current](/docs/current/custom-scan-path.html "PostgreSQL
17 - 61.1. Creating Custom Scan Paths") ([17](/docs/17/custom-scan-path.html
"PostgreSQL 17 - 61.1. Creating Custom Scan Paths")) / [16](/docs/16/custom-
scan-path.html "PostgreSQL 16 - 61.1. Creating Custom Scan Paths") /
[15](/docs/15/custom-scan-path.html "PostgreSQL 15 - 61.1. Creating Custom
Scan Paths") / [14](/docs/14/custom-scan-path.html "PostgreSQL 14 -
61.1. Creating Custom Scan Paths") / [13](/docs/13/custom-scan-path.html
"PostgreSQL 13 - 61.1. Creating Custom Scan Paths")

Development Versions: [18](/docs/18/custom-scan-path.html "PostgreSQL 18 -
61.1. Creating Custom Scan Paths") / [devel](/docs/devel/custom-scan-path.html
"PostgreSQL devel - 61.1. Creating Custom Scan Paths")

Unsupported versions: [12](/docs/12/custom-scan-path.html "PostgreSQL 12 -
61.1. Creating Custom Scan Paths") / [11](/docs/11/custom-scan-path.html
"PostgreSQL 11 - 61.1. Creating Custom Scan Paths") / [10](/docs/10/custom-
scan-path.html "PostgreSQL 10 - 61.1. Creating Custom Scan Paths") /
[9.6](/docs/9.6/custom-scan-path.html "PostgreSQL 9.6 - 61.1. Creating Custom
Scan Paths") / [9.5](/docs/9.5/custom-scan-path.html "PostgreSQL 9.5 -
61.1. Creating Custom Scan Paths")

__

61.1. Creating Custom Scan Paths  
---  
[Prev](custom-scan.html "Chapter 61. Writing a Custom Scan Provider")  | [Up](custom-scan.html "Chapter 61. Writing a Custom Scan Provider") | Chapter 61. Writing a Custom Scan Provider | [Home](index.html "PostgreSQL 16.9 Documentation") |  [Next](custom-scan-plan.html "61.2. Creating Custom Scan Plans")  
  
* * *

## 61.1. Creating Custom Scan Paths #

[61.1.1. Custom Scan Path Callbacks](custom-scan-path.html#CUSTOM-SCAN-PATH-
CALLBACKS)

A custom scan provider will typically add paths for a base relation by setting
the following hook, which is called after the core code has generated all the
access paths it can for the relation (except for Gather paths, which are made
after this call so that they can use partial paths added by the hook):

    
    
    typedef void (*set_rel_pathlist_hook_type) (PlannerInfo *root,
                                                RelOptInfo *rel,
                                                Index rti,
                                                RangeTblEntry *rte);
    extern PGDLLIMPORT set_rel_pathlist_hook_type set_rel_pathlist_hook;
    

Although this hook function can be used to examine, modify, or remove paths
generated by the core system, a custom scan provider will typically confine
itself to generating `CustomPath` objects and adding them to `rel` using
`add_path`. The custom scan provider is responsible for initializing the
`CustomPath` object, which is declared like this:

    
    
    typedef struct CustomPath
    {
        Path      path;
        uint32    flags;
        List     *custom_paths;
        List     *custom_private;
        const CustomPathMethods *methods;
    } CustomPath;
    

`path` must be initialized as for any other path, including the row-count
estimate, start and total cost, and sort ordering provided by this path.
`flags` is a bit mask, which specifies whether the scan provider can support
certain optional capabilities. `flags` should include
`CUSTOMPATH_SUPPORT_BACKWARD_SCAN` if the custom path can support a backward
scan, `CUSTOMPATH_SUPPORT_MARK_RESTORE` if it can support mark and restore,
and `CUSTOMPATH_SUPPORT_PROJECTION` if it can perform projections. (If
`CUSTOMPATH_SUPPORT_PROJECTION` is not set, the scan node will only be asked
to produce Vars of the scanned relation; while if that flag is set, the scan
node must be able to evaluate scalar expressions over these Vars.) An optional
`custom_paths` is a list of `Path` nodes used by this custom-path node; these
will be transformed into `Plan` nodes by planner. `custom_private` can be used
to store the custom path's private data. Private data should be stored in a
form that can be handled by `nodeToString`, so that debugging routines that
attempt to print the custom path will work as designed. `methods` must point
to a (usually statically allocated) object implementing the required custom
path methods, which are further detailed below.

A custom scan provider can also provide join paths. Just as for base
relations, such a path must produce the same output as would normally be
produced by the join it replaces. To do this, the join provider should set the
following hook, and then within the hook function, create `CustomPath` path(s)
for the join relation.

    
    
    typedef void (*set_join_pathlist_hook_type) (PlannerInfo *root,
                                                 RelOptInfo *joinrel,
                                                 RelOptInfo *outerrel,
                                                 RelOptInfo *innerrel,
                                                 JoinType jointype,
                                                 JoinPathExtraData *extra);
    extern PGDLLIMPORT set_join_pathlist_hook_type set_join_pathlist_hook;
    

This hook will be invoked repeatedly for the same join relation, with
different combinations of inner and outer relations; it is the responsibility
of the hook to minimize duplicated work.

### 61.1.1. Custom Scan Path Callbacks #

    
    
    Plan *(*PlanCustomPath) (PlannerInfo *root,
                             RelOptInfo *rel,
                             CustomPath *best_path,
                             List *tlist,
                             List *clauses,
                             List *custom_plans);
    

Convert a custom path to a finished plan. The return value will generally be a
`CustomScan` object, which the callback must allocate and initialize. See
[Section 61.2](custom-scan-plan.html "61.2. Creating Custom Scan Plans") for
more details.

    
    
    List *(*ReparameterizeCustomPathByChild) (PlannerInfo *root,
                                              List *custom_private,
                                              RelOptInfo *child_rel);
    

This callback is called while converting a path parameterized by the top-most
parent of the given child relation `child_rel` to be parameterized by the
child relation. The callback is used to reparameterize any paths or translate
any expression nodes saved in the given `custom_private` member of a
`CustomPath`. The callback may use `reparameterize_path_by_child`,
`adjust_appendrel_attrs` or `adjust_appendrel_attrs_multilevel` as required.

* * *

[Prev](custom-scan.html "Chapter 61. Writing a Custom Scan Provider")  | [Up](custom-scan.html "Chapter 61. Writing a Custom Scan Provider") |  [Next](custom-scan-plan.html "61.2. Creating Custom Scan Plans")  
---|---|---  
Chapter 61. Writing a Custom Scan Provider  | [Home](index.html "PostgreSQL 16.9 Documentation") |  61.2. Creating Custom Scan Plans  
  
## Submit correction

If you see anything in the documentation that is not correct, does not match
your experience with the particular feature or requires further clarification,
please use [this form](/account/comments/new/16/custom-scan-path.html/) to
report a documentation issue.

[Privacy Policy](/about/privacypolicy) | [Code of Conduct](/about/policies/coc/) | [About PostgreSQL](/about/) | [Contact](/about/contact/)  

Copyright (C) 1996-2025 The PostgreSQL Global Development Group

